<HTML>
<HEAD>
<TITLE>Data::Table - Data type related to database tables, spreadsheets, CSV/TSV files, HTML table displays, etc.</TITLE>
<LINK REV="made" HREF="mailto:prospector@porky.devel.redhat.com">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#abstract">ABSTRACT</A></LI>
	<LI><A HREF="#introduction">INTRODUCTION</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#field summary">Field Summary</A></LI>
		<LI><A HREF="#package variables">Package Variables</A></LI>
		<LI><A HREF="#class methods">Class Methods</A></LI>
		<LI><A HREF="#table creation">Table Creation</A></LI>
		<LI><A HREF="#table access and properties">Table Access and Properties</A></LI>
		<LI><A HREF="#table formatting">Table Formatting</A></LI>
		<LI><A HREF="#table operations">Table Operations</A></LI>
		<LI><A HREF="#tabletable manipulations">Table-Table Manipulations</A></LI>
		<LI><A HREF="#internal methods">Internal Methods</A></LI>
	</UL>

	<LI><A HREF="#tsv format">TSV FORMAT</A></LI>
	<LI><A HREF="#interface to other softwares">INTERFACE TO OTHER SOFTWARES</A></LI>
	<UL>

		<LI><A HREF="#interface to database and web">Interface to Database and Web</A></LI>
		<LI><A HREF="#interface to csv/tsv">Interface to CSV/TSV</A></LI>
		<LI><A HREF="#interface to graphics package">Interface to Graphics Package</A></LI>
	</UL>

	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>Data::Table - Data type related to database tables, spreadsheets, CSV/TSV files, HTML table displays, etc.</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  # some cool ways to use Table.pm
  use Data::Table;
</PRE>
<PRE>

  $header = [&quot;name&quot;, &quot;age&quot;];
  $data = [
    [&quot;John&quot;, 20],
    [&quot;Kate&quot;, 18],
    [&quot;Mike&quot;, 23]
  ];
  $t = new Data::Table($data, $header, 0);      # Construct a table object with
                                        # $data, $header, $type=0 (consider 
                                        # $data as the rows of the table).
  print $t-&gt;csv;                        # Print out the table as a csv file.</PRE>
<P></P>
<PRE>

  $t = Data::Table::fromCSV(&quot;aaa.csv&quot;);       # Read a csv file into a table oject
  print $t-&gt;html;                       # Diplay a 'portrait' HTML TABLE on web.</PRE>
<PRE>
  use DBI;
  $dbh= DBI-&gt;connect(&quot;DBI:mysql:test&quot;, &quot;test&quot;, &quot;&quot;) or die $DBI::errstr;
  my $minAge = 10;
  $t = Data::Table::fromSQL($dbh, &quot;select * from mytable where age &gt;= ?&quot;, [$minAge]);
                                        # Construct a table form an SQL 
                                        # database query.</PRE>
<PRE>
  $t-&gt;sort(&quot;age&quot;, 0, 0);                # Sort by col 'age',numerical,descending
  print $t-&gt;html2;                      # Print out a 'landscape' HTML Table.</PRE>
<PRE>
  $row = $t-&gt;delRow(2);                 # Delete the third row (index=2).
  $t-&gt;addRow($row, 4);                  # Add the deleted row back as fifth row. 
  @rows = $t-&gt;delRows([0..2]);          # Delete three rows (row 0 to 2).
  $col = $t-&gt;delCol(&quot;age&quot;);             # Delete column 'age'.
  $t-&gt;addCol($col, &quot;age&quot;,2);            # Add column 'age' as the third column
  @cols = $t-&gt;delCols([&quot;name&quot;,&quot;phone&quot;,&quot;ssn&quot;]); 
                                        # Delete 3 columns at the same time.</PRE>
<PRE>
  $name =  $t-&gt;elm(2,&quot;name&quot;);           # Element access
  $t2=$t-&gt;subTable([1, 3..4],['age', 'name']);  
                                        # Extract a sub-table</PRE>
<PRE>
  $t-&gt;rename(&quot;Entry&quot;, &quot;New Entry&quot;);     # Rename column 'Entry' by 'New Entry'
  $t-&gt;replace(&quot;Entry&quot;, [1..$t-&gt;nofRow()], &quot;New Entry&quot;); 
                                        # Replace column 'Entry' by an array of
                                        # numbers and rename it as 'New Entry'
  $t-&gt;swap(&quot;age&quot;,&quot;ssn&quot;);                # Swap the positions of column 'age' 
                                        # with column 'ssn' in the table.</PRE>
<PRE>
  $t-&gt;colMap('name', sub {return uc});  # Map a function to a column 
  $t-&gt;sort('age',0,0,'name',1,0);       # Sort table first by the numerical 
                                        # column 'age' and then by the 
                                        # string column 'name' in descending
                                        # order
  $t2=$t-&gt;match_pattern('$_-&gt;[0] =~ /^L/ &amp;&amp; $_-&gt;[3]&lt;0.2'); 
                                        # Select the rows that matched the 
                                        # pattern specified 
  $t2=$t-&gt;match_string('John');         # Select the rows that matches 'John'   
                                        # in any column</PRE>
<PRE>
  $t2=$t-&gt;clone();                      # Make a copy of the table.
  $t-&gt;rowMerge($t2);                    # Merge two tables
  $t-&gt;colMerge($t2);</PRE>
<PRE>
  $t = new Data::Table(                 # create an employ salary table
    [
      ['Tom', 'male', 'IT', 65000],
      ['John', 'male', 'IT', 75000],
      ['Tom', 'male', 'IT', 65000],
      ['John', 'male', 'IT', 75000],
      ['Peter', 'male', 'HR', 85000],
      ['Mary', 'female', 'HR', 80000],
      ['Nancy', 'female', 'IT', 55000],
      ['Jack', 'male', 'IT', 88000],
      ['Susan', 'female', 'HR', 92000]
    ],
    ['Name', 'Sex', 'Department', 'Salary'], 0);
</PRE>
<PRE>

  sub average {  # this is an subroutine calculate mathematical average, ignore NULL
    my @data = @_;
    my ($sum, $n) = (0, 0);
    foreach $x (@data) {
      next unless $x;
      $sum += $x; $n++;
    }
    return ($n&gt;0)?$sum/$n:undef;
  }</PRE>
<PRE>

  $t2 = $t-&gt;group([&quot;Department&quot;,&quot;Sex&quot;],[&quot;Name&quot;, &quot;Salary&quot;], [sub {scalar @_}, \&amp;average], [&quot;Nof Employee&quot;, &quot;Average Salary&quot;]);
  # For each (Department,Sex) pair, calculate the number of employees and average salary
  $t2 = $t2-&gt;pivot(&quot;Sex&quot;, 0, &quot;Average Salary&quot;, [&quot;Department&quot;]);
  # Show average salary information in a Department by Sex spreadsheet</PRE>
<P>
<HR>
<H1><A NAME="abstract">ABSTRACT</A></H1>
<P>This perl package uses perl5 objects to make it easy for
manipulating spreadsheet data among disk files, database, and Web
publishing.</P>
<P>A table object contains a header and a two-dimensional array of scalars.
Three class methods Data::Table::fromCSV, Data::Table::fromTSV, and Data::Table::fromSQL allow users
to create a table object from a CSV/TSV file or a database SQL selection in a snap.</P>
<P>Table methods provide basic access, add, delete <A HREF="#item_row"><CODE>row(s)</CODE></A> or <CODE>column(s)</CODE> operations, as well as more advanced sub-table extraction, table sorting,
record matching via keywords or patterns, table merging, and web publishing.   
Data::Table class also provides a straightforward interface to other
popular Perl modules such as DBI and GD::Graph.</P>
<P>The current version of Table.pm is available at <A HREF="http://www.geocities.com/easydatabase">http://www.geocities.com/easydatabase</A></P>
<P>We use Data::Table instead of Table, because Table.pm has already been used inside PerlQt module in CPAN.</P>
<P>
<HR>
<H1><A NAME="introduction">INTRODUCTION</A></H1>
<P>A table object has three data members:</P>
<OL>
<LI><STRONG><A NAME="item_%24data%3A">$data:</A></STRONG><BR>

a reference to an array of array-references.
It's basically a reference to a two-dimensional array.
<P></P>
<LI><STRONG><A NAME="item_%24header%3A">$header:</A></STRONG><BR>

a reference to a string array. The array contains all the column names.
<P></P>
<LI><STRONG><A NAME="item_%24type_%3D_1_or_0%2E">$type = 1 or 0.</A></STRONG><BR>

1 means that @$data is an array of table columns (fields) (column-based);
0 means that @$data is an array of table rows (records) (row-based);
<P></P></OL>
<P>Row-based/Column-based are two internal implementations for a table object.
E.g., if a spreadsheet consists of two columns lastname and age.
In a row-based table, $data = [ ['Smith', 29], ['Dole', 32] ].
In a column-based table, $data = [ ['Smith', 'Dole'], [29, 32] ].</P>
<P>Two implementions have their pros and cons for different operations.
Row-based implementation is better for sorting and pattern matching,
while column-based one is better for adding/deleting/swapping columns.</P>
<P>Users only need to specify the implementation type of the table upon its
creation via Data::Table::new, and can forget about it afterwards.
Implementation type of a table should be considered volital, because
methods switch table objects from one type into another internally.
Be advised that row/column/element references gained via table::rowRef,
table::rowRefs, table::colRef, table::colRefs, or table::elmRef may
become stale after other method calls afterwards.</P>
<P>For those who want to inherit from the Data::Table class, internal method
table::rotate is used to switch from one implementation type into another.
There is an additional internal assistant data structure called
colHash in our current implementation. This hash
table stores all column names and their corresponding column index number as
key-value pairs for fast conversion. This gives users an option to use
column name wherever a column ID is expected, so that user don't have to use
table::colIndex all the time. E.g., you may say
$t-&gt;rename('oldColName', 'newColName')
instead of $t-&gt;rename($t-&gt;colIndex('oldColName'), 'newColIdx').</P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>
<H2><A NAME="field summary">Field Summary</A></H2>
<DL>
<DT><STRONG><A NAME="item_data_refto_arrayof_refto_array">data refto_arrayof_refto_array</A></STRONG><BR>
<DD>
contains a two-dimensional spreadsheet data.
<P></P>
<DT><STRONG><A NAME="item_header_refto_array">header refto_array</A></STRONG><BR>
<DD>
contains all column names.
<P></P>
<DT><STRONG><A NAME="item_type">type 0/1</A></STRONG><BR>
<DD>
0 is row-based, 1 is column-based, describe the orientation of @$data.
<P></P></DL>
<P>
<H2><A NAME="package variables">Package Variables</A></H2>
<DL>
<DT><STRONG><A NAME="item_%24Data%3A%3ATable%3A%3AVERSION">$Data::Table::VERSION</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_%40Data%3A%3ATable%3A%3AOK">@Data::Table::OK</A></STRONG><BR>
<DD>
see table::match_string and table::match_pattern
<P># =item $Data::Table::ID
# 
#see Data::Table::fromSQL</P>
<P></P></DL>
<P>
<H2><A NAME="class methods">Class Methods</A></H2>
<P>Syntax: return_type method_name ( [ parameter [ = default_value ]] [, parameter [ = default_value ]] )</P>
<P>If method_name starts with table::, this is an instance method, it can be used as $t-&gt;method( parameters ), where $t is a table reference.</P>
<P>If method_name starts with Data::Table::, this is a class method, it should be called as
  Data::Table::method, e.g., $t = Data::Table::fromCSV(``filename.csv'').</P>
<P>Convensions for local variables:</P>
<PRE>
  colID: either a numerical column index or a column name;
  rowIdx: numerical row index;
  rowIDsRef: reference to an array of column IDs;
  rowIdcsRef: reference to an array of row indices;
  rowRef, colRef: reference to an array of scalars;
  data: ref_to_array_of_ref_to_array of data values;
  header: ref to array of column headers;
  table: a table object, a blessed reference.</PRE>
<P>
<H2><A NAME="table creation">Table Creation</A></H2>
<DL>
<DT><STRONG><A NAME="item_new">table Data::Table::new ( $data = [], $header = [], $type = 0, $enforceCheck = 1)</A></STRONG><BR>
<DD>
create a new table.
It returns a table object upon success, undef otherwise.
$data: points to the spreadsheet data.
$header: points to an array of column names. A column name must have at least one non-digit character.
$type: 0 or 1 for row-based/column-based spreadsheet.
$enforceCheck: 1/0 to turn on/off initial checking on the size of each row/column to make sure the data arguement indeed points to a valid structure.
<P></P>
<DT><STRONG><A NAME="item_subTable">table table::subTable ($rowIdcsRef, $colIDsRef)</A></STRONG><BR>
<DD>
create a new table, which is a subset of the original.
It returns a table object.
$rowIdcsRef: points to an array of row indices.
$colIDsRef: points to an array of column IDs.
The function make a copy of selected elements from the original table. 
Undefined $rowIdcsRef or $colIDsRef is interpreted as all rows or all columns.
<P></P>
<DT><STRONG><A NAME="item_table_table%3A%3Aclone">table table::clone</A></STRONG><BR>
<DD>
make a clone of the original.
It return a table object, equivalent to table::subTable(undef,undef).
<P></P>
<DT><STRONG><A NAME="item_fromCSV">table Data::Table::fromCSV ($name, $includeHeader = 1, $header = [``col1'', ... ])</A></STRONG><BR>
<DD>
create a table from a CSV file.
return a table object.
$name: the CSV file name.
$includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are ``col1'', ``col2'', ...
<P></P>
<DT><STRONG><A NAME="item_fromCSVi">table table::fromCSVi ($name, $includeHeader = 1, $header = [``col1'', ... ])</A></STRONG><BR>
<DD>
Same as Data::Table::fromCSV. However, this is an instant method (that's what 'i' stands for), which can be inherited.
<P></P>
<DT><STRONG><A NAME="item_fromTSV">table Data::Table::fromTSV ($name, $includeHeader = 1, $header = [``col1'', ... ])</A></STRONG><BR>
<DD>
create a table from a TSV file.
return a table object.
$name: the TSV file name.
$includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are ``col1'', ``col2'', ...
<P>Note: read ``TSV FORMAT'' section for details.</P>
<P></P>
<DT><STRONG><A NAME="item_fromTSVi">table table::fromTSVi ($name, $includeHeader = 1, $header = [``col1'', ... ])</A></STRONG><BR>
<DD>
Same as Data::Table::fromTSV. However, this is an instant method (that's what 'i' stands for), whic
h can be inherited.
<P></P>
<DT><STRONG><A NAME="item_fromSQL">table Data::Table::fromSQL ($dbh, $sql, $vars)</A></STRONG><BR>
<DD>
create a table from the result of an SQL selection query.
It returns a table object upon success or undef otherwise.
$dbh: a valid database handler. 
Typically $dbh is obtained from DBI-&gt;connect, see ``Interface to Database'' or DBI.pm.
$sql: an SQL query string.
$vars: optional reference to an array of variable values, 
required if $sql contains '?'s which need to be replaced 
by the corresponding variable values upon execution, see DBI.pm for details.
Hint: in MySQL, Data::Table::fromSQL($dbh, 'show tables from test') will also create a valid table object.
<P></P>
<DT><STRONG><A NAME="item_fromSQLi">table Data::Table::fromSQLi ($dbh, $sql, $vars)</A></STRONG><BR>
<DD>
Same as Data::Table::fromSQL. However, this is an instant method (that's what 'i' stands for), whic
h can be inherited.
<P></P></DL>
<P>
<H2><A NAME="table access and properties">Table Access and Properties</A></H2>
<DL>
<DT><STRONG><A NAME="item_colIndex">int table::colIndex ($colID)</A></STRONG><BR>
<DD>
translate a column name into its numerical position, the first column has index 0 as in as any perl array.
return -1 for invalid column names.
<P></P>
<DT><STRONG><A NAME="item_int_table%3A%3AnofCol">int table::nofCol</A></STRONG><BR>
<DD>
return number of columns.
<P></P>
<DT><STRONG><A NAME="item_int_table%3A%3AnofRow">int table::nofRow</A></STRONG><BR>
<DD>
return number of rows.
<P></P>
<DT><STRONG><A NAME="item_elm">scalar table::elm ($rowIdx, $colID)</A></STRONG><BR>
<DD>
return the value of a table element at [$rowIdx, $colID],
undef if $rowIdx or $colID is invalid.
<P></P>
<DT><STRONG><A NAME="item_elmRef">refto_scalar table::elmRef ($rowIdx, $colID)</A></STRONG><BR>
<DD>
return the reference to a table element at [$rowIdx, $colID], to allow possible modification.
It returns undef for invalid $rowIdx or $colID.
<P></P>
<DT><STRONG><A NAME="item_header">array table::header ($header)</A></STRONG><BR>
<DD>
Without argument, it returns an array of column names.
Otherwise, use the new header.
<P></P>
<DT><STRONG><A NAME="item_int_table%3A%3Atype">int table::type</A></STRONG><BR>
<DD>
return the implementation type of the table (row-based/column-based) at the time,
be aware that the type of a table should be considered as volital during method calls.
<P></P></DL>
<P>
<H2><A NAME="table formatting">Table Formatting</A></H2>
<DL>
<DT><STRONG><A NAME="item_string_table%3A%3Acsv">string table::csv</A></STRONG><BR>
<DD>
return a string corresponding to the CSV representation of the table.
<P></P>
<DT><STRONG><A NAME="item_string_table%3A%3Atsv">string table::tsv</A></STRONG><BR>
<DD>
return a string corresponding to the TSV representation of the table.
<P>Note: read ``TSV FORMAT'' section for details.</P>
<P></P>
<DT><STRONG><A NAME="item_html">string table::html ($colors = [``#D4D4BF'',``#ECECE4'',``#CCCC99''], 
			  $tag_tbl = {border =&gt; '1'},
                          $tag_tr  = {align =&gt; 'left'},
                          $tag_th  = {align =&gt; 'center'},
                          $tag_td  = {col3 =&gt; 'align=right valign=bottom', 4 =&gt; 'align=left'},
                          $l_portrait = 1
                        )</A></STRONG><BR>
<DD>
return a string corresponding to a 'Portrait/Lanscape'-style html-tagged table.
$colors: a reference to an array of three color strings, used for backgrounds for table header, odd-row records, and even-row records, respectively. 
A default color array (``#D4D4BF'',``#ECECE4'',``#CCCC99'')
will be used if $colors isn't defined.
<P>$tag_tbl: a reference to a hash that specifies any legal attributes such as name, border,
id, class, etc. for the TABLE tag.</P>
<P>$tag_tr: a reference to a hash that specifies any legal attributes for the TR tag.</P>
<P>$tag_th: a reference to a hash that specifies any legal attributes for the TH tag.</P>
<P>$tag_td: a reference to a hash that specifies any legal attributes for the TD tag.</P>
<P>Notice $tag_tr and $tag_th controls all the rows and columns of the whole table. The keys of the hash are the attribute names in these cases. However, $tag_td is column specific, i.e., you should specify TD attributes for every column separately.
The key of %$tag_td are either column names or column indices, the value is the full string to be inserted into the TD tag. E.g., $tag_td  = {col3 =&gt; 'align=right valign=bottom} only change the TD tag in ``col3'' to be &amp;lt;TD align=right valign=bottom&amp;gt;.</P>
<P>$portrait controls the layout of the table. The default is 1, i.e., the table is shown in the
``Portrait'' style, like in Excel. 0 means ``Landscape''.</P>
<P></P>
<DT><STRONG><A NAME="item_html2">string table::html2 ($colors = [``#D4D4BF'',``#ECECE4'',``#CCCC99''],
		 	   $specs = {'name' =&gt; '', 'border' =&gt; '1', ...})</A></STRONG><BR>
<DD>
This method is depricated. It's here for compatibility. It now simple call html method with $portrait = 0, see previous description.
<P>return a string corresponding to a ``Landscape'' html-tagged table.
This is useful to present a table with many columns, but very few entries.
Check the above table::html for parameter descriptions.</P>
<P></P></DL>
<P>
<H2><A NAME="table operations">Table Operations</A></H2>
<DL>
<DT><STRONG><A NAME="item_setElm">int table::setElm ($rowIdx, $colID, $val)</A></STRONG><BR>
<DD>
modify the value of a table element at [$rowIdx, $colID] to a new value $val.
It returns 1 upon success, undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_addRow">int table::addRow ( $rowRef, $rowIdx = table::nofRow)</A></STRONG><BR>
<DD>
add a new row ($rowRef points to the actual list of scalars), the new row will be referred as $rowIdx as the result. E.g., addRow($aRow, 0) will put the new row as the very first row.
By default, it appends a row to the end.
It returns 1 upon success, undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_delRow">refto_array table::delRow ( $rowIdx )</A></STRONG><BR>
<DD>
delete a row at $rowIdx. It will the reference to the deleted row.
<P></P>
<DT><STRONG><A NAME="item_delRows">refto_array table::delRows ( $rowIdcsRef )</A></STRONG><BR>
<DD>
delete rows in @$rowIdcsRef. It will return an array of deleted rows
upon success.
<P></P>
<DT><STRONG><A NAME="item_addCol">int table::addCol ($colRef, $colName, $colIdx = numCol)</A></STRONG><BR>
<DD>
add a new column ($colRef points to the actual data), the new column will be referred as $colName or $colIdx as the result. E.g., addCol($aCol, 'newCol', 0) will put the new column as the very first column.
By default, append a row to the end.
It will return 1 upon success or undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_delCol">refto_array table::delCol ($colID)</A></STRONG><BR>
<DD>
delete a column at $colID
return the reference to the deleted column.
<P></P>
<DT><STRONG><A NAME="item_delCols">arrayof_refto_array table::delCols ($colIDsRef)</A></STRONG><BR>
<DD>
delete a list of columns, pointed by $colIDsRef. It will
return an array of deleted columns upon success.
<P></P>
<DT><STRONG><A NAME="item_rowRef">refto_array table::rowRef ($rowIdx)</A></STRONG><BR>
<DD>
return a reference to the row at $rowIdx
upon success or undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_rowRefs">refto_arrayof_refto_array table::rowRefs ($rowIdcsRef)</A></STRONG><BR>
<DD>
return a reference to array of row references upon success, undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_row">array table::row ($rowIdx)</A></STRONG><BR>
<DD>
return a copy of the row at $rowIdx 
upon success or undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_rowHashRef">refto_hash table::rowHashRef ($rowIdx)</A></STRONG><BR>
<DD>
return a reference to a hash, which contains a copy of the row at $rowIdx,
upon success or undef otherwise. The keys in the hash are column names, and
the values are corresponding elements in that row. The hash is a copy, therefore modifying the hash values doesn't change the original table.
<P></P>
<DT><STRONG><A NAME="item_colRef">refto_array table::colRef ($colID)</A></STRONG><BR>
<DD>
return a reference to the column at $colID
upon success.
<P></P>
<DT><STRONG><A NAME="item_colRefs">refto_arrayof_refto_array table::colRefs ($colIDsRef)</A></STRONG><BR>
<DD>
return a reference to array of column references upon success.
<P></P>
<DT><STRONG><A NAME="item_col">array table::col ($colID)</A></STRONG><BR>
<DD>
return a copy to the column at $colID
upon success or undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_rename">int table::rename ($colID, $newName)</A></STRONG><BR>
<DD>
rename the column at $colID to a $newName 
(the newName must be valid, 
and should not be idential to any other existing column names).
It returns 1 upon success
or undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_replace">refto_array table::replace ($oldColID, $newColRef, $newName)</A></STRONG><BR>
<DD>
replace the column at $oldColID by the array pointed by $newColRef, and renamed it to $newName. $newName is optional if you don't want to rename the column.
It returns 1 upon success or undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_swap">int table::swap ($colID1, $colID2)</A></STRONG><BR>
<DD>
swap two columns referred by $colID1 and $colID2.
It returns 1 upon success or undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_colMap">int table::colMap ($colID, $fun)</A></STRONG><BR>
<DD>
foreach element in column $colID, map a function $fun to it.
It returns 1 upon success or undef otherwise.
This is a handy way to format a column. E.g. if a column named URL contains URL strings, colMap(``URL'', sub {``&lt;a href='$_'&gt;$_&lt;/a&gt;''}) before <A HREF="#item_html"><CODE>html()</CODE></A> will change each URL into a clickable hyper link while displayed in a web browser.
<P></P>
<DT><STRONG><A NAME="item_colsMap">int table::colsMap ($fun)</A></STRONG><BR>
<DD>
foreach row in the table, map a function $fun to it.
It can do whatever colMap can do and more.
It returns 1 upon success or undef otherwise.
colMap function only give $fun access to the particular element per row, while colsMap give $fun full access to all elements per row. E.g. if two columns named duration and unit ([``2'', ``hrs''], [``30'', ``sec'']). colsMap(sub {$_-&gt;[0] .= `` (''.$_-&gt;[1].``)''; } will change each row into ([``2 hrs'', ``hrs''], [``30 sec'', ``sec'']).
As show, in the $func, a column element should be referred as $_-&gt;[$colIndex].
<P></P>
<DT><STRONG><A NAME="item_sort">int table::sort($colID1, $type1, $order1, $colID2, $type2, $order2, ... )</A></STRONG><BR>
<DD>
sort a table in place.
First sort by column $colID1 in $order1 as $type1, then sort by $colID2 in $order2 as $type2, ...
$type is 0 for numerical and 1 for others;
$order is 0 for ascending and 1 for descending;
Sorting is done in the priority of colID1, colID2, ...
It returns 1 upon success or undef otherwise. 
Notice the table is rearranged as a result! This is different from perl's list sort, which returns a sorted copy while leave the original list untouched, 
the authors feel inplace sorting is more natural.
<P></P>
<DT><STRONG><A NAME="item_match_pattern">table table::match_pattern ($pattern, $countOnly)</A></STRONG><BR>
<DD>
return a new table consisting those rows evaluated to be true by $pattern 
upon success or undef otherwise. If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
<P>Side effect: @Data::Table::OK stores a true/false array for the original table rows. Using it, users can find out what are the rows being selected/unselected.
In the $pattern string, a column element should be referred as $_-&gt;[$colIndex]. E.g., match_pattern('$_-&gt;[0]&gt;3 &amp;&amp; $_-&gt;[1]=~/^L') retrieve all the rows where its first column is greater than 3 and second column starts with letter 'L'. Notice it only takes colIndex, column names are not acceptable here!</P>
<P></P>
<DT><STRONG><A NAME="item_match_string">table table::match_string ($s, $caseIgnore, $countOnly)</A></STRONG><BR>
<DD>
return a new table consisting those rows contains string $s in any of its fields upon success, undef otherwise. if $caseIgnore evaluated to true, case will is be ignored (s/$s/i). If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
<P>Side effect: @Data::Table::OK stores a true/false array for the original table rows. 
Using it, users can find out what are the rows being selected/unselected.
The $s string is actually treated as a regular expression and 
applied to each row element, therefore one can actually specify several keywords 
by saying, for instance, match_string('One|Other').</P>
<P></P>
<DT><STRONG><A NAME="item_rowMask">table table::rowMask($mask, $complement)</A></STRONG><BR>
<DD>
mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).
<P>E.g., $t1=$tbl-&gt;match_string('keyword'); $t2=$tbl-&gt;rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while $t2 contains all other rows.</P>
<P>mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return
 a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).</P>
<P>E.g., $t1=$tbl-&gt;match_string('keyword'); $t2=$tbl-&gt;rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while 
$t2 contains all other rows.</P>
<P></P>
<DT><STRONG><A NAME="item_group">table table::group($colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames)</A></STRONG><BR>
<DD>
Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first. Then for each group, an array of subroutines (in $funsToAppy) are applied to corresponding columns and yield a list of new columns (specified in $newColNames).
<P>$colsToGroupBy, $colsToCalculate are references to array of colIDs. $funsToApply is a reference to array of subroutine references. $newColNames are a
reference to array of new column name strings. If specified, the size of arrays pointed by $colsToCalculate, $funsToApply and $newColNames should be i
dentical. A column may be used more than once in $colsToCalculate.</P>
<P>E.g., an employee salary table $t contains the following columns: Name, Sex, Department, Salary. (see examples in the SYNOPSIS)</P>
<P>$t2 = $t-&gt;group([``Department'',``Sex''],[``Name'', ``Salary''], [sub {scalar @_}, \&amp;average], [``Nof Employee'', ``Average Salary'']);</P>
<P>Department, Sex are used together as the primary key columns, a new column ``Nof Employee'' is created by counting the number of employee names in each group, a new column ``Average Salary'' is created by averaging the Salary data falled into each group. As the result, we have the head count and average salary information for each (Department, Sex) pair. With your own functions (such as sum, product, average, standard deviation, etc), group method is very handy for accounting purpose.</P>
<P></P>
<DT><STRONG><A NAME="item_pivot">table table::pivot($colToSplit, $colToSplitIsNumeric, $colToFill, $colsToGroupBy, $keepRestCols)</A></STRONG><BR>
<DD>
Every unique values in a column (specified by $colToSplit) become a new column. undef value become ``NULL''.  If the column type is numeric (specified by $colToSplitIsNumeric), the new column names are prefixed by ``oldColumnName=''. The new cell element is filled by the value specified by $colToFill.
<P>When primary key columns are specified by $colsToGroupBy, all records sharing the same primary key collapse into one row, with values in $colToFill filling the corresponding new columns. If $colToFill is not specified, a cell is filled with 1 if there is a corresponding data record in the original table.</P>
<P>$colToSplit and $colToFill are colIDs. $colToSplitIsNumeric is 1/0. $colsToGroupBy is a reference to array of colIDs. $keepRestCols is 1/0, by default is 0. If $keepRestCols is off, only primary key columns and new columns are exported, otherwise, all the rest columns are exported as well.</P>
<P>E.g., applying pivot method to the resultant table of the example of the group method.</P>
<P>$t2-&gt;pivot(``Sex'', 0, ``Average Salary'',[``Department'']);</P>
<P>This creates a 2x3 table, where Departments are use as row keys, Sex (female and male) become two new columns. ``Average Salary'' values are used to fill the new table elements. Used together with group method, pivot method is very handy for account type of analysis.</P>
<P></P></DL>
<P>
<H2><A NAME="tabletable manipulations">Table-Table Manipulations</A></H2>
<DL>
<DT><STRONG><A NAME="item_rowMerge">int table::rowMerge ($tbl)</A></STRONG><BR>
<DD>
Append all the rows in the table object $tbl to the original rows.
The merging table $tbl must have the same number of columns as the original.
It returns 1 upon success, undef otherwise.
The table object $tbl should not be used afterwards, since it becomes part of
the new table.
<P></P>
<DT><STRONG><A NAME="item_colMerge">int table::colMerge ($tbl)</A></STRONG><BR>
<DD>
Append all the columns in table object $tbl to the original columns. 
Table $tbl must have the same number of rows as the original.
It returns 1 upon success, undef otherwise.
Table $tbl should not be used afterwards, since it becomes part of
the new table.
<P></P>
<DT><STRONG><A NAME="item_join">table table::join ($tbl, $type, $cols1, $cols2)</A></STRONG><BR>
<DD>
Join two tables. The following join types are supported (defined by $type):
<P>0: inner join
1: left outer join
2: right outer join
3: full outer join</P>
<P>$cols1 and $cols2 are references to array of colIDs, where rows with the same elements in all listed columns are merged. As the result table, columns listed in $cols2 are deleted, before a new table is returned.</P>
<P>The implementation is hash-join, the running time should be linear with respect to the sum of number of rows in the two tables (assume both tables fit in memeory).</P>
<P></P></DL>
<P>
<H2><A NAME="internal methods">Internal Methods</A></H2>
<P>All internal methods are mainly implemented for used by 
other methods in the Table class. Users should avoid using them.
Nevertheless, they are listed here for developers who 
would like to understand the code and may derive a new class from Data::Table.</P>
<DL>
<DT><STRONG><A NAME="item_int_table%3A%3Arotate">int table::rotate</A></STRONG><BR>
<DD>
convert the internal structure of a table between row-based and column-based.
return 1 upon success, undef otherwise.
<P></P>
<DT><STRONG><A NAME="item_csvEscape">string <CODE>csvEscape($rowRef)</CODE></A></STRONG><BR>
<DD>
Encode an array of scalars into a CSV-formatted string.
<P></P>
<DT><STRONG><A NAME="item_parseCSV">refto_array <CODE>parseCSV($string)</CODE></A></STRONG><BR>
<DD>
Break a CSV encoded string to an array of scalars (check it out, we did it the cool way).
<P></P>
<DT><STRONG><A NAME="item_tsvEscape">string <CODE>tsvEscape($rowRef)</CODE></A></STRONG><BR>
<DD>
Encode an array of scalars into a TSV-formatted string.
<P></P>
<DT><STRONG><A NAME="item_parseTSV">refto_array <CODE>parseTSV($string)</CODE></A></STRONG><BR>
<DD>
Break a TSV encoded string to an array of scalars (check it out, we did it the cool way).
<P></P></DL>
<P>
<HR>
<H1><A NAME="tsv format">TSV FORMAT</A></H1>
<P>There is no standard for TSV format as far as we know. CSV format can't handle binary data very well, therefore, we choose the TSV format to overcome this limitation.</P>
<P>We define TSV based on MySQL convention.</P>
<PRE>
  &quot;\0&quot;, &quot;\n&quot;, &quot;\t&quot;, &quot;\r&quot;, &quot;\b&quot;, &quot;'&quot;, &quot;\&quot;&quot;, and &quot;\\&quot; are all escaped by '\' in the TSV file.
  (Warning: MySQL treats '\f' as 'f', and it's not escaped here)
  Undefined values are represented as '\N'.</PRE>
<P>
<HR>
<H1><A NAME="interface to other softwares">INTERFACE TO OTHER SOFTWARES</A></H1>
<P>Spreadsheet is a very generic type, therefore Data::Table class provides an easy
interface between databases, web pages, CSV/TSV files, graphics packages, etc.</P>
<P>Here is a summary (partially repeat) of some classic usages of Data::Table.</P>
<P>
<H2><A NAME="interface to database and web">Interface to Database and Web</A></H2>
<PRE>
  use DBI;</PRE>
<PRE>
  $dbh= DBI-&gt;connect(&quot;DBI:mysql:test&quot;, &quot;test&quot;, &quot;&quot;) or die $DBI::errstr;
  my $minAge = 10;
  $t = Data::Table::fromSQL($dbh, &quot;select * from mytable where age &gt;= ?&quot;, [$minAge]);
  print $t-&gt;html;</PRE>
<P>
<H2><A NAME="interface to csv/tsv">Interface to CSV/TSV</A></H2>
<PRE>
  $t = fromCSV(&quot;mydata.csv&quot;);
  $t-&gt;sort(1,1,0);
  print $t-&gt;csv;</PRE>
<PRE>
  Same for TSV</PRE>
<P>
<H2><A NAME="interface to graphics package">Interface to Graphics Package</A></H2>
<PRE>
  use GD::Graph::points;</PRE>
<PRE>
  $graph = GD::Graph::points-&gt;new(400, 300);
  $t2 = $t-&gt;match('$_-&gt;[1] &gt; 20 &amp;&amp; $_-&gt;[3] &lt; 35.7');
  my $gd = $graph-&gt;plot($t-&gt;colRefs([0,2]));
  open(IMG, '&gt;mygraph.png') or die $!;
  binmode IMG;
  print IMG $gd-&gt;png;
  close IMG;</PRE>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Copyright 1998-2000, Yingyao Zhou &amp; Guangzhou Zou. All rights reserved.</P>
<P>It was first written by Zhou in 1998, significantly improved and maintained by Zou since 1999. The authors thank Tong Peng and Yongchuang Tao for valuable suggestions. We also thank those who kindly reported bugs, some of them are acknowledged in the ``Changes'' file.</P>
<P>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</P>
<P>Please send bug reports and comments to: <A HREF="mailto:easydatabase@yahoo.com.">easydatabase@yahoo.com.</A> When sending
bug reports, please provide the version of Table.pm, the version of
Perl.</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<PRE>
  DBI, GD::Graph.</PRE>

</BODY>

</HTML>
